<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Disparos Espaciales - Estilo Gradius</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 100%);
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            border: 3px solid #00ffff;
            box-shadow: 0 0 20px #00ffff, inset 0 0 20px rgba(0, 255, 255, 0.1);
        }

        #gameCanvas {
            display: block;
            background: #000011;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00ffff;
            font-size: 16px;
            text-shadow: 0 0 10px #00ffff;
            z-index: 10;
        }

        #ui div {
            margin-bottom: 5px;
        }

        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        #gameOverScreen h1 {
            color: #ff0055;
            font-size: 48px;
            text-shadow: 0 0 20px #ff0055;
            margin-bottom: 20px;
        }

        #gameOverScreen p {
            color: #00ffff;
            font-size: 20px;
            margin-bottom: 10px;
        }

        #restartBtn {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 20px;
            font-family: 'Courier New', Courier, monospace;
            background: transparent;
            border: 2px solid #00ff00;
            color: #00ff00;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        #restartBtn:hover {
            background: #00ff00;
            color: #000;
            box-shadow: 0 0 20px #00ff00;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 17, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 25;
        }

        #startScreen h1 {
            color: #00ffff;
            font-size: 36px;
            text-shadow: 0 0 20px #00ffff;
            margin-bottom: 30px;
            text-align: center;
        }

        #startScreen .instructions {
            color: #aaa;
            font-size: 14px;
            margin-bottom: 20px;
            text-align: center;
            line-height: 1.8;
        }

        #startBtn {
            padding: 15px 40px;
            font-size: 20px;
            font-family: 'Courier New', Courier, monospace;
            background: transparent;
            border: 2px solid #00ffff;
            color: #00ffff;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        #startBtn:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 20px #00ffff;
        }

        #levelUpScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 15;
        }

        #levelUpScreen h2 {
            color: #ffff00;
            font-size: 42px;
            text-shadow: 0 0 20px #ffff00;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="ui">
            <div>PUNTUACIN: <span id="score">0</span></div>
            <div>NIVEL: <span id="level">1</span></div>
            <div>VIDAS: <span id="lives">3</span></div>
        </div>

        <div id="startScreen">
            <h1> DISPAROS ESPACIALES </h1>
            <div class="instructions">
                猬锔猬锔猬锔★ - Mover nave<br>
                ESPACIO - Disparar<br><br>
                隆Destruye todos los enemigos!<br>
                Sobrevive los 5 niveles para ganar.
            </div>
            <button id="startBtn">INICIAR JUEGO</button>
        </div>

        <div id="gameOverScreen">
            <h1>GAME OVER</h1>
            <p>Puntuaci贸n Final: <span id="finalScore">0</span></p>
            <p>Nivel Alcanzado: <span id="finalLevel">1</span></p>
            <button id="restartBtn">REINICIAR</button>
        </div>

        <div id="levelUpScreen">
            <h2 id="levelUpText">隆NIVEL 2!</h2>
        </div>
    </div>

    <script>
        // ==========================================
        // SISTEMA DE CARGA DE IMGENES
        // ==========================================
        const ImageLoader = {
            images: {},
            loaded: false,
            
            // URLs de las im谩genes
            URLS: {
                player: 'https://i.redd.it/yct20hubfk061.png',
                enemy: 'https://png.pngtree.com/png-vector/20250922/ourmid/pngtree-neon-retro-spaceship-pixel-art-with-vibrant-exhaust-png-image_17538670.webp',
                background: 'https://images.unsplash.com/photo-1506318137071-a8bcbf67cc77?q=80&w=2070&auto=format&fit=crop'
            },
            
            load() {
                return new Promise((resolve) => {
                    const imageKeys = Object.keys(this.URLS);
                    let loadedCount = 0;
                    let failedCount = 0;
                    
                    imageKeys.forEach((key) => {
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        
                        img.onload = () => {
                            this.images[key] = img;
                            loadedCount++;
                            if (loadedCount + failedCount === imageKeys.length) {
                                this.loaded = true;
                                resolve(this.images);
                            }
                        };
                        
                        img.onerror = () => {
                            console.warn(`Failed to load image: ${key}`);
                            this.images[key] = null;
                            failedCount++;
                            if (loadedCount + failedCount === imageKeys.length) {
                                this.loaded = true;
                                resolve(this.images);
                            }
                        };
                        
                        img.src = this.URLS[key];
                    });
                });
            },
            
            get(key) {
                return this.images[key] || null;
            }
        };

        // ==========================================
        // CLASE: Bala (Bullet)
        // ==========================================
        class Bala {
            constructor(x, y, velocidad = 10, esJugador = true) {
                this.x = x;
                this.y = y;
                this.ancho = 15;
                this.alto = 4;
                this.velocidad = velocidad;
                this.esJugador = esJugador;
                this.activa = true;
            }

            actualizar() {
                if (this.esJugador) {
                    this.x += this.velocidad;
                } else {
                    this.x -= this.velocidad;
                }

                // Desactivar si sale de la pantalla
                // Canvas width is 800, so use 800 + 50 margin
                const canvasWidth = 800;
                if (this.x > canvasWidth + 50 || this.x < -20) {
                    this.activa = false;
                }
            }

            dibujar(ctx) {
                if (this.esJugador) {
                    // Bala del jugador - color cyan
                    ctx.fillStyle = '#00ffff';
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = 10;
                } else {
                    // Bala enemiga - color rojo
                    ctx.fillStyle = '#ff0055';
                    ctx.shadowColor = '#ff0055';
                    ctx.shadowBlur = 10;
                }
                
                ctx.fillRect(this.x, this.y, this.ancho, this.alto);
                ctx.shadowBlur = 0;
            }

            obtenerLimites() {
                return {
                    x: this.x,
                    y: this.y,
                    ancho: this.ancho,
                    alto: this.alto
                };
            }
        }

        // ==========================================
        // CLASE: Jugador (Player)
        // ==========================================
        class Jugador {
            constructor(canvas) {
                this.canvas = canvas;
                // Ajustar tama帽o para coincidir con el sprite
                this.ancho = 60;
                this.alto = 40;
                this.x = 50;
                this.y = canvas.height / 2 - this.alto / 2;
                this.velocidad = 5;
                this.vidas = 3;
                this.invulnerable = false;
                this.tiempoInvulnerable = 0;
                this.tiempoUltimoDisparo = 0;
                this.cadenciaDisparo = 200; // ms entre disparos
                
                // Control de movimiento
                this.movimiento = {
                    arriba: false,
                    abajo: false,
                    izquierda: false,
                    derecha: false
                };
            }

            actualizar(deltaTime) {
                // Movimiento
                if (this.movimiento.arriba && this.y > 0) {
                    this.y -= this.velocidad;
                }
                if (this.movimiento.abajo && this.y < this.canvas.height - this.alto) {
                    this.y += this.velocidad;
                }
                if (this.movimiento.izquierda && this.x > 0) {
                    this.x -= this.velocidad;
                }
                if (this.movimiento.derecha && this.x < this.canvas.width - this.ancho) {
                    this.x += this.velocidad;
                }

                // Actualizar invulnerabilidad
                if (this.invulnerable) {
                    this.tiempoInvulnerable -= deltaTime;
                    if (this.tiempoInvulnerable <= 0) {
                        this.invulnerable = false;
                    }
                }
            }

            dibujar(ctx) {
                // Parpadeo cuando es invulnerable
                if (this.invulnerable && Math.floor(Date.now() / 100) % 2 === 0) {
                    return;
                }

                ctx.save();
                
                const playerImg = ImageLoader.get('player');
                if (playerImg) {
                    // Dibujar el sprite del jugador
                    ctx.drawImage(playerImg, this.x, this.y, this.ancho, this.alto);
                } else {
                    // Fallback: dibujar forma geom茅trica si la imagen no carg贸
                    ctx.fillStyle = '#00ff88';
                    ctx.shadowColor = '#00ff88';
                    ctx.shadowBlur = 15;
                    
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.ancho, this.y + this.alto / 2);
                    ctx.lineTo(this.x, this.y);
                    ctx.lineTo(this.x + 10, this.y + this.alto / 2);
                    ctx.lineTo(this.x, this.y + this.alto);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = '#ff6600';
                    ctx.shadowColor = '#ff6600';
                    ctx.beginPath();
                    ctx.moveTo(this.x + 5, this.y + 8);
                    ctx.lineTo(this.x - 10, this.y + this.alto / 2);
                    ctx.lineTo(this.x + 5, this.y + this.alto - 8);
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.restore();
            }

            disparar(tiempoActual) {
                if (tiempoActual - this.tiempoUltimoDisparo >= this.cadenciaDisparo) {
                    this.tiempoUltimoDisparo = tiempoActual;
                    return new Bala(this.x + this.ancho, this.y + this.alto / 2 - 2, 12, true);
                }
                return null;
            }

            recibirDano() {
                if (!this.invulnerable) {
                    this.vidas--;
                    this.invulnerable = true;
                    this.tiempoInvulnerable = 2000; // 2 segundos de invulnerabilidad
                    return true;
                }
                return false;
            }

            reiniciar() {
                this.x = 50;
                this.y = this.canvas.height / 2 - this.alto / 2;
                this.vidas = 3;
                this.invulnerable = false;
                this.movimiento = {
                    arriba: false,
                    abajo: false,
                    izquierda: false,
                    derecha: false
                };
            }

            obtenerLimites() {
                return {
                    x: this.x,
                    y: this.y,
                    ancho: this.ancho,
                    alto: this.alto
                };
            }
        }

        // ==========================================
        // CLASE: Enemigo (Enemy)
        // ==========================================
        class Enemigo {
            constructor(canvas, nivel) {
                this.canvas = canvas;
                // Ajustar tama帽o para coincidir con el sprite
                this.ancho = 50;
                this.alto = 35;
                this.x = canvas.width + this.ancho;
                this.y = Math.random() * (canvas.height - this.alto - 40) + 20;
                
                // Velocidad base aumenta con el nivel
                this.velocidadBase = 2 + (nivel * 0.5);
                this.velocidad = this.velocidadBase + Math.random() * 1.5;
                
                this.puntos = 100 * nivel;
                this.activo = true;
                
                // Movimiento ondulatorio
                this.amplitud = Math.random() * 30 + 10;
                this.frecuencia = Math.random() * 0.05 + 0.02;
                this.fase = Math.random() * Math.PI * 2;
                this.yInicial = this.y;
                
                // Sistema de disparo
                this.tiempoUltimoDisparo = Date.now();
                this.intervaloDisparo = 2000 + Math.random() * 2000; // Entre 2 y 4 segundos
                this.probabilidadDisparo = 0.005 + (nivel * 0.002); // Aumenta con el nivel
                this.velocidadBala = 5 + nivel; // Velocidad de las balas enemigas
            }

            actualizar() {
                this.x -= this.velocidad;
                
                // Movimiento ondulatorio
                this.fase += this.frecuencia;
                this.y = this.yInicial + Math.sin(this.fase) * this.amplitud;
                
                // Limitar dentro del canvas
                if (this.y < 10) this.y = 10;
                if (this.y > this.canvas.height - this.alto - 10) {
                    this.y = this.canvas.height - this.alto - 10;
                }

                // Desactivar si sale por la izquierda
                if (this.x < -this.ancho) {
                    this.activo = false;
                }
            }
            
            // M茅todo para intentar disparar
            intentarDisparar() {
                // Solo disparar si el enemigo est谩 visible en la pantalla
                if (this.x > this.canvas.width || this.x < 0) {
                    return null;
                }
                
                const tiempoActual = Date.now();
                
                // Usar probabilidad por frame O temporizador
                const tiempoTranscurrido = tiempoActual - this.tiempoUltimoDisparo;
                const debeDisparar = (tiempoTranscurrido >= this.intervaloDisparo) || 
                                     (Math.random() < this.probabilidadDisparo && tiempoTranscurrido > 500);
                
                if (debeDisparar) {
                    this.tiempoUltimoDisparo = tiempoActual;
                    // Crear bala enemiga (esJugador = false, va hacia la izquierda, color rojo)
                    return new Bala(this.x, this.y + this.alto / 2 - 2, this.velocidadBala, false);
                }
                
                return null;
            }

            dibujar(ctx) {
                ctx.save();
                
                const enemyImg = ImageLoader.get('enemy');
                if (enemyImg) {
                    // Dibujar el sprite del enemigo (volteado horizontalmente para que mire a la izquierda)
                    ctx.translate(this.x + this.ancho, this.y);
                    ctx.scale(-1, 1);
                    ctx.drawImage(enemyImg, 0, 0, this.ancho, this.alto);
                } else {
                    // Fallback: dibujar forma geom茅trica si la imagen no carg贸
                    ctx.fillStyle = '#ff3366';
                    ctx.shadowColor = '#ff3366';
                    ctx.shadowBlur = 10;
                    
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y + this.alto / 2);
                    ctx.lineTo(this.x + this.ancho, this.y);
                    ctx.lineTo(this.x + this.ancho - 10, this.y + this.alto / 2);
                    ctx.lineTo(this.x + this.ancho, this.y + this.alto);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = '#ffff00';
                    ctx.shadowColor = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(this.x + 15, this.y + this.alto / 2, 5, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }

            obtenerLimites() {
                return {
                    x: this.x,
                    y: this.y,
                    ancho: this.ancho,
                    alto: this.alto
                };
            }
        }

        // ==========================================
        // CLASE: Terrain (Estilo Gradius - Generaci贸n Procedural)
        // ==========================================
        class Terrain {
            constructor(canvas) {
                this.canvas = canvas;
                this.segmentWidth = 50; // Ancho de cada segmento del terreno
                this.scrollSpeed = 2; // Velocidad de scroll
                this.offsetX = 0; // Desplazamiento horizontal acumulado
                
                // Colores retro
                this.rockColor = '#8B4513'; // Marr贸n arcilla
                this.mossColor = '#228B22'; // Verde musgo
                
                // Configuraci贸n del terreno superior e inferior
                this.topTerrainHeight = 60; // Altura m谩xima del terreno superior
                this.bottomTerrainHeight = 60; // Altura m谩xima del terreno inferior
                
                // Arrays de puntos para el terreno (generados proceduralmente)
                this.topPoints = [];
                this.bottomPoints = [];
                
                // Generar puntos iniciales
                this.initializeTerrain();
            }
            
            initializeTerrain() {
                // Calcular cu谩ntos segmentos necesitamos para cubrir la pantalla + buffer
                const numSegments = Math.ceil(this.canvas.width / this.segmentWidth) + 3;
                
                // Generar puntos iniciales para el terreno superior
                for (let i = 0; i < numSegments; i++) {
                    this.topPoints.push({
                        x: i * this.segmentWidth,
                        height: this.generateRandomHeight(this.topTerrainHeight)
                    });
                }
                
                // Generar puntos iniciales para el terreno inferior
                for (let i = 0; i < numSegments; i++) {
                    this.bottomPoints.push({
                        x: i * this.segmentWidth,
                        height: this.generateRandomHeight(this.bottomTerrainHeight)
                    });
                }
            }
            
            generateRandomHeight(maxHeight) {
                // Generar altura irregular para el terreno
                return Math.random() * maxHeight * 0.6 + maxHeight * 0.2;
            }
            
            actualizar() {
                // Desplazar el terreno hacia la izquierda
                this.offsetX += this.scrollSpeed;
                
                // Actualizar posiciones de los puntos superiores
                for (let point of this.topPoints) {
                    point.x -= this.scrollSpeed;
                }
                
                // Actualizar posiciones de los puntos inferiores
                for (let point of this.bottomPoints) {
                    point.x -= this.scrollSpeed;
                }
                
                // Eliminar puntos que salen por la izquierda y generar nuevos por la derecha
                // Terreno superior
                if (this.topPoints.length > 0 && this.topPoints[0].x < -this.segmentWidth) {
                    this.topPoints.shift();
                    const lastPoint = this.topPoints[this.topPoints.length - 1];
                    this.topPoints.push({
                        x: lastPoint.x + this.segmentWidth,
                        height: this.generateRandomHeight(this.topTerrainHeight)
                    });
                }
                
                // Terreno inferior
                if (this.bottomPoints.length > 0 && this.bottomPoints[0].x < -this.segmentWidth) {
                    this.bottomPoints.shift();
                    const lastPoint = this.bottomPoints[this.bottomPoints.length - 1];
                    this.bottomPoints.push({
                        x: lastPoint.x + this.segmentWidth,
                        height: this.generateRandomHeight(this.bottomTerrainHeight)
                    });
                }
            }
            
            dibujar(ctx) {
                // Dibujar terreno superior (techo)
                this.dibujarTerrenoSuperior(ctx);
                
                // Dibujar terreno inferior (suelo)
                this.dibujarTerrenoInferior(ctx);
            }
            
            dibujarTerrenoSuperior(ctx) {
                if (this.topPoints.length < 2) return;
                
                ctx.save();
                
                // Dibujar la roca (relleno marr贸n)
                ctx.fillStyle = this.rockColor;
                ctx.beginPath();
                ctx.moveTo(this.topPoints[0].x, 0);
                
                for (let point of this.topPoints) {
                    ctx.lineTo(point.x, point.height);
                }
                
                // Cerrar el pol铆gono
                ctx.lineTo(this.topPoints[this.topPoints.length - 1].x, 0);
                ctx.closePath();
                ctx.fill();
                
                // Dibujar el borde verde (musgo/c茅sped)
                ctx.strokeStyle = this.mossColor;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(this.topPoints[0].x, this.topPoints[0].height);
                
                for (let i = 1; i < this.topPoints.length; i++) {
                    ctx.lineTo(this.topPoints[i].x, this.topPoints[i].height);
                }
                ctx.stroke();
                
                ctx.restore();
            }
            
            dibujarTerrenoInferior(ctx) {
                if (this.bottomPoints.length < 2) return;
                
                ctx.save();
                
                // Dibujar la roca (relleno marr贸n)
                ctx.fillStyle = this.rockColor;
                ctx.beginPath();
                ctx.moveTo(this.bottomPoints[0].x, this.canvas.height);
                
                for (let point of this.bottomPoints) {
                    ctx.lineTo(point.x, this.canvas.height - point.height);
                }
                
                // Cerrar el pol铆gono
                ctx.lineTo(this.bottomPoints[this.bottomPoints.length - 1].x, this.canvas.height);
                ctx.closePath();
                ctx.fill();
                
                // Dibujar el borde verde (musgo/c茅sped)
                ctx.strokeStyle = this.mossColor;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(this.bottomPoints[0].x, this.canvas.height - this.bottomPoints[0].height);
                
                for (let i = 1; i < this.bottomPoints.length; i++) {
                    ctx.lineTo(this.bottomPoints[i].x, this.canvas.height - this.bottomPoints[i].height);
                }
                ctx.stroke();
                
                ctx.restore();
            }
            
            // Detecci贸n de colisi贸n con el terreno
            detectarColision(objeto) {
                const limites = objeto.obtenerLimites();
                const x = limites.x;
                const y = limites.y;
                const ancho = limites.ancho;
                const alto = limites.alto;
                
                // Verificar colisi贸n con el terreno superior
                for (let i = 0; i < this.topPoints.length - 1; i++) {
                    const p1 = this.topPoints[i];
                    const p2 = this.topPoints[i + 1];
                    
                    // Verificar si el objeto est谩 en el rango horizontal del segmento
                    if (x + ancho >= p1.x && x <= p2.x) {
                        // Interpolar la altura del terreno en la posici贸n del objeto
                        const dx = p2.x - p1.x;
                        const t = dx !== 0 ? (x + ancho / 2 - p1.x) / dx : 0;
                        const terrainHeight = p1.height + (p2.height - p1.height) * Math.max(0, Math.min(1, t));
                        
                        // Colisi贸n si el objeto est谩 por encima del terreno superior
                        if (y < terrainHeight) {
                            return true;
                        }
                    }
                }
                
                // Verificar colisi贸n con el terreno inferior
                for (let i = 0; i < this.bottomPoints.length - 1; i++) {
                    const p1 = this.bottomPoints[i];
                    const p2 = this.bottomPoints[i + 1];
                    
                    // Verificar si el objeto est谩 en el rango horizontal del segmento
                    if (x + ancho >= p1.x && x <= p2.x) {
                        // Interpolar la altura del terreno en la posici贸n del objeto
                        const dx = p2.x - p1.x;
                        const t = dx !== 0 ? (x + ancho / 2 - p1.x) / dx : 0;
                        const terrainHeight = p1.height + (p2.height - p1.height) * Math.max(0, Math.min(1, t));
                        
                        // Colisi贸n si el objeto est谩 por debajo del terreno inferior
                        if (y + alto > this.canvas.height - terrainHeight) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
        }

        // ==========================================
        // CLASE: Estrella (para fondo)
        // ==========================================
        class Estrella {
            constructor(canvas) {
                this.canvas = canvas;
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.tamano = Math.random() * 2 + 0.5;
                this.velocidad = Math.random() * 3 + 1;
                this.brillo = Math.random();
            }

            actualizar() {
                this.x -= this.velocidad;
                if (this.x < 0) {
                    this.x = this.canvas.width;
                    this.y = Math.random() * this.canvas.height;
                }
            }

            dibujar(ctx) {
                ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + this.brillo * 0.7})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.tamano, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // ==========================================
        // CLASE: GameManager
        // ==========================================
        class GameManager {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Elementos UI
                this.scoreElement = document.getElementById('score');
                this.levelElement = document.getElementById('level');
                this.livesElement = document.getElementById('lives');
                this.startScreen = document.getElementById('startScreen');
                this.gameOverScreen = document.getElementById('gameOverScreen');
                this.levelUpScreen = document.getElementById('levelUpScreen');
                this.finalScoreElement = document.getElementById('finalScore');
                this.finalLevelElement = document.getElementById('finalLevel');
                this.levelUpText = document.getElementById('levelUpText');
                
                // Estado del juego
                this.jugador = null;
                this.enemigos = [];
                this.balas = [];
                this.estrellas = [];
                this.terrain = null; // Terreno estilo Gradius
                this.puntuacion = 0;
                this.nivel = 1;
                this.nivelMaximo = 5;
                this.enJuego = false;
                this.pausado = false;
                
                // Fondo parallax
                this.fondoX = 0;
                this.fondoVelocidad = 1; // Velocidad del scrolling
                
                // Temporizadores
                this.ultimoTiempo = 0;
                this.tiempoSpawnEnemigo = 0;
                this.intervaloSpawnBase = 2000; // ms
                this.enemigosDestruidos = 0;
                this.enemigosPorNivel = 10;
                
                // Control de disparo
                this.disparando = false;
                
                // Inicializar
                this.inicializarEstrellas();
                this.configurarEventos();
            }

            inicializarEstrellas() {
                this.estrellas = [];
                for (let i = 0; i < 100; i++) {
                    this.estrellas.push(new Estrella(this.canvas));
                }
            }

            configurarEventos() {
                // Botones
                document.getElementById('startBtn').addEventListener('click', () => this.iniciarJuego());
                document.getElementById('restartBtn').addEventListener('click', () => this.reiniciarJuego());

                // Teclado
                document.addEventListener('keydown', (e) => this.manejarTeclaPresionada(e));
                document.addEventListener('keyup', (e) => this.manejarTeclaSoltada(e));
            }

            manejarTeclaPresionada(e) {
                if (!this.jugador || !this.enJuego) return;

                switch(e.code) {
                    case 'ArrowUp':
                    case 'KeyW':
                        this.jugador.movimiento.arriba = true;
                        e.preventDefault();
                        break;
                    case 'ArrowDown':
                    case 'KeyS':
                        this.jugador.movimiento.abajo = true;
                        e.preventDefault();
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        this.jugador.movimiento.izquierda = true;
                        e.preventDefault();
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        this.jugador.movimiento.derecha = true;
                        e.preventDefault();
                        break;
                    case 'Space':
                        this.disparando = true;
                        e.preventDefault();
                        break;
                }
            }

            manejarTeclaSoltada(e) {
                if (!this.jugador) return;

                switch(e.code) {
                    case 'ArrowUp':
                    case 'KeyW':
                        this.jugador.movimiento.arriba = false;
                        break;
                    case 'ArrowDown':
                    case 'KeyS':
                        this.jugador.movimiento.abajo = false;
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        this.jugador.movimiento.izquierda = false;
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        this.jugador.movimiento.derecha = false;
                        break;
                    case 'Space':
                        this.disparando = false;
                        break;
                }
            }

            iniciarJuego() {
                this.startScreen.style.display = 'none';
                this.gameOverScreen.style.display = 'none';
                
                this.jugador = new Jugador(this.canvas);
                this.terrain = new Terrain(this.canvas); // Inicializar terreno
                this.enemigos = [];
                this.balas = [];
                this.puntuacion = 0;
                this.nivel = 1;
                this.enemigosDestruidos = 0;
                this.enJuego = true;
                this.disparando = false;
                
                this.actualizarUI();
                this.ultimoTiempo = performance.now();
                this.tiempoSpawnEnemigo = this.ultimoTiempo;
                
                // Game loop is already running from DOMContentLoaded, no need to start again
            }

            reiniciarJuego() {
                this.iniciarJuego();
            }

            obtenerIntervaloSpawn() {
                // Reducir intervalo de spawn con cada nivel
                return Math.max(500, this.intervaloSpawnBase - (this.nivel - 1) * 300);
            }

            spawnEnemigo() {
                const enemigo = new Enemigo(this.canvas, this.nivel);
                this.enemigos.push(enemigo);
            }

            detectarColision(a, b) {
                const limA = a.obtenerLimites();
                const limB = b.obtenerLimites();
                
                return limA.x < limB.x + limB.ancho &&
                       limA.x + limA.ancho > limB.x &&
                       limA.y < limB.y + limB.alto &&
                       limA.y + limA.alto > limB.y;
            }

            procesarColisiones() {
                // Balas del jugador vs Enemigos
                for (let i = this.balas.length - 1; i >= 0; i--) {
                    const bala = this.balas[i];
                    if (!bala.esJugador || !bala.activa) continue;

                    for (let j = this.enemigos.length - 1; j >= 0; j--) {
                        const enemigo = this.enemigos[j];
                        if (!enemigo.activo) continue;

                        if (this.detectarColision(bala, enemigo)) {
                            bala.activa = false;
                            enemigo.activo = false;
                            this.puntuacion += enemigo.puntos;
                            this.enemigosDestruidos++;
                            
                            // Verificar subida de nivel
                            if (this.enemigosDestruidos >= this.enemigosPorNivel) {
                                this.subirNivel();
                            }
                            break;
                        }
                    }
                }

                // Balas enemigas vs Jugador
                for (let i = this.balas.length - 1; i >= 0; i--) {
                    const bala = this.balas[i];
                    if (bala.esJugador || !bala.activa) continue;

                    if (this.detectarColision(bala, this.jugador)) {
                        bala.activa = false;
                        if (this.jugador.recibirDano()) {
                            if (this.jugador.vidas <= 0) {
                                this.gameOver();
                                return;
                            }
                        }
                    }
                }

                // Enemigos vs Jugador
                for (const enemigo of this.enemigos) {
                    if (!enemigo.activo) continue;
                    
                    if (this.detectarColision(this.jugador, enemigo)) {
                        if (this.jugador.recibirDano()) {
                            enemigo.activo = false;
                            if (this.jugador.vidas <= 0) {
                                this.gameOver();
                                return;
                            }
                        }
                    }
                }
                
                // Colisi贸n con el terreno (jugador)
                if (this.terrain && this.terrain.detectarColision(this.jugador)) {
                    if (this.jugador.recibirDano()) {
                        if (this.jugador.vidas <= 0) {
                            this.gameOver();
                            return;
                        }
                    }
                }
            }

            subirNivel() {
                if (this.nivel >= this.nivelMaximo) {
                    // Victoria!
                    this.mostrarVictoria();
                    return;
                }

                this.nivel++;
                this.enemigosDestruidos = 0;
                
                // Mostrar pantalla de nivel
                this.levelUpText.textContent = `隆NIVEL ${this.nivel}!`;
                this.levelUpScreen.style.display = 'flex';
                
                setTimeout(() => {
                    this.levelUpScreen.style.display = 'none';
                }, 1500);
            }

            mostrarVictoria() {
                this.enJuego = false;
                this.gameOverScreen.querySelector('h1').textContent = '隆VICTORIA!';
                this.gameOverScreen.querySelector('h1').style.color = '#00ff00';
                this.finalScoreElement.textContent = this.puntuacion;
                this.finalLevelElement.textContent = this.nivel;
                this.gameOverScreen.style.display = 'flex';
            }

            gameOver() {
                this.enJuego = false;
                this.gameOverScreen.querySelector('h1').textContent = 'GAME OVER';
                this.gameOverScreen.querySelector('h1').style.color = '#ff0055';
                this.finalScoreElement.textContent = this.puntuacion;
                this.finalLevelElement.textContent = this.nivel;
                this.gameOverScreen.style.display = 'flex';
            }

            actualizarUI() {
                this.scoreElement.textContent = this.puntuacion;
                this.levelElement.textContent = this.nivel;
                this.livesElement.textContent = this.jugador ? this.jugador.vidas : 0;
            }

            actualizar(tiempoActual) {
                const deltaTime = tiempoActual - this.ultimoTiempo;
                this.ultimoTiempo = tiempoActual;

                // Actualizar estrellas
                for (const estrella of this.estrellas) {
                    estrella.actualizar();
                }

                if (!this.enJuego) return;

                // Actualizar terreno (scroll infinito)
                if (this.terrain) {
                    this.terrain.actualizar();
                }

                // Spawn de enemigos
                if (tiempoActual - this.tiempoSpawnEnemigo >= this.obtenerIntervaloSpawn()) {
                    this.spawnEnemigo();
                    this.tiempoSpawnEnemigo = tiempoActual;
                }

                // Disparar (jugador)
                if (this.disparando) {
                    const bala = this.jugador.disparar(tiempoActual);
                    if (bala) {
                        this.balas.push(bala);
                    }
                }

                // Actualizar jugador
                this.jugador.actualizar(deltaTime);

                // Actualizar enemigos y procesar sus disparos
                for (const enemigo of this.enemigos) {
                    enemigo.actualizar();
                    
                    // Intentar que el enemigo dispare
                    const balaEnemiga = enemigo.intentarDisparar();
                    if (balaEnemiga) {
                        this.balas.push(balaEnemiga);
                    }
                }

                // Actualizar balas
                for (const bala of this.balas) {
                    bala.actualizar();
                }

                // Detectar colisiones
                this.procesarColisiones();

                // Limpiar objetos inactivos
                this.enemigos = this.enemigos.filter(e => e.activo);
                this.balas = this.balas.filter(b => b.activa);

                // Actualizar UI
                this.actualizarUI();
            }

            dibujar() {
                // Dibujar fondo parallax
                const bgImg = ImageLoader.get('background');
                if (bgImg) {
                    // Calcular posiciones para scrolling infinito
                    const imgWidth = this.canvas.width;
                    const imgHeight = this.canvas.height;
                    
                    // Dibujar dos copias de la imagen para efecto de scrolling continuo
                    this.ctx.drawImage(bgImg, this.fondoX, 0, imgWidth, imgHeight);
                    this.ctx.drawImage(bgImg, this.fondoX + imgWidth, 0, imgWidth, imgHeight);
                    
                    // Actualizar posici贸n del fondo
                    this.fondoX -= this.fondoVelocidad;
                    if (this.fondoX <= -imgWidth) {
                        this.fondoX = 0;
                    }
                } else {
                    // Fallback: fondo oscuro si la imagen no carg贸
                    this.ctx.fillStyle = '#000011';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }

                // Dibujar estrellas (encima del fondo para efecto de profundidad)
                for (const estrella of this.estrellas) {
                    estrella.dibujar(this.ctx);
                }

                // Dibujar terreno (detr谩s del jugador y los enemigos)
                if (this.terrain) {
                    this.terrain.dibujar(this.ctx);
                }

                if (!this.enJuego && !this.jugador) return;

                // Dibujar balas
                for (const bala of this.balas) {
                    bala.dibujar(this.ctx);
                }

                // Dibujar enemigos
                for (const enemigo of this.enemigos) {
                    enemigo.dibujar(this.ctx);
                }

                // Dibujar jugador
                if (this.jugador) {
                    this.jugador.dibujar(this.ctx);
                }

                // Indicador de progreso del nivel
                if (this.enJuego) {
                    this.dibujarBarraProgreso();
                }
            }

            dibujarBarraProgreso() {
                const barraAncho = 150;
                const barraAlto = 10;
                const x = this.canvas.width - barraAncho - 20;
                const y = 15;
                const progreso = this.enemigosDestruidos / this.enemigosPorNivel;

                // Fondo
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(x, y, barraAncho, barraAlto);

                // Progreso
                this.ctx.fillStyle = '#00ff00';
                this.ctx.fillRect(x, y, barraAncho * progreso, barraAlto);

                // Borde
                this.ctx.strokeStyle = '#00ff00';
                this.ctx.strokeRect(x, y, barraAncho, barraAlto);

                // Texto
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '10px Courier New';
                this.ctx.fillText(`${this.enemigosDestruidos}/${this.enemigosPorNivel}`, x + barraAncho + 5, y + 9);
            }

            gameLoop(tiempoActual) {
                this.actualizar(tiempoActual);
                this.dibujar();

                // Always continue the game loop - it handles both active game and background animation
                requestAnimationFrame((t) => this.gameLoop(t));
            }
        }

        // ==========================================
        // INICIALIZACIN
        // ==========================================
        document.addEventListener('DOMContentLoaded', async () => {
            // Mostrar mensaje de carga
            const startBtn = document.getElementById('startBtn');
            startBtn.textContent = 'CARGANDO...';
            startBtn.disabled = true;
            
            // Cargar im谩genes antes de permitir iniciar el juego
            await ImageLoader.load();
            
            // Habilitar bot贸n de inicio
            startBtn.textContent = 'INICIAR JUEGO';
            startBtn.disabled = false;
            
            const game = new GameManager();
            // Iniciar animaci贸n del fondo antes de empezar
            game.gameLoop(performance.now());
        });
    </script>
</body>
</html>
